#! /usr/bin/env python
import irclib
import ircbot
import time
import sys
import thread
import os
import random
import commands
import urllib
import BeautifulSoup
import HTMLParser
import re
from lxml import html
import urllib2
import logging
pubTimeCommand = ".time"
privTimeCommand = ".time"
sayCommand = ".speak"
PMTimeCommand = ".ptime"
log = "no"
logfile = "users.txt"
amounts = []
HTMLParserObject = HTMLParser.HTMLParser()


class Bot(ircbot.SingleServerIRCBot):
    def __init__ (self, channels, nick, server, port, password, name, silentChannels):
        ircbot.SingleServerIRCBot.__init__(self, [(server,port)], nick, name, 10)
        self.nick = nick
        self.mychannels = channels
        self.password = password
        self.currentHour = self.getHour()
        self.currentMin = self.getMin() #sets current hour and minute, minute doesn't do anything right now
        self.amounts = amounts
        self.silentChannels = silentChannels
        thread.start_new_thread(self.wait, ()) #listens for the time change in a separate thread so we can listen for input as well
        if log == "yes":
            thread.start_new_thread(self.setupLog, ()) #starts a new thread that sets up the users per channel
        self.array = []
        self.commandnicks = []
        self.responses = []
        self.ignores = []
        self.message = '' #message for the .time command
        self.custom = 0;

    def getHour(self):
        theTime = time.gmtime()#does things for GMT
        longHour = theTime.tm_hour #using this because I am far more comfortable with C than I am with Python
        shortHour = longHour % 12
        return shortHour

    def getTweets(self, username, number):
        try:
            self.url = "https://api.twitter.com/1/statuses/user_timeline.xml?screen_name=" + username + "&count=" + str(number)
            self.page = urllib.urlopen(self.url)
            self.soup = BeautifulSoup.BeautifulSoup(self.page.read())
            self.tweets = self.soup.findAll('text')
            if len(self.tweets) == 0:
                return "No tweets found on this page."
            else:
                return (HTMLParser.HTMLParser().unescape(self.tweets[-1].text)).encode('utf-8')
                #gets the nth tweet from the user's page
        except:
            return "Error retrieving that user's tweets. Perhaps the account is suspended?"
            # accounts for a 401 error

    def urban(self, term, number):
        try:
            self.url = "http://www.urbandictionary.com/define.php?term=" + term
            self.page = urllib.urlopen(self.url)
            self.soup = BeautifulSoup.BeautifulSoup(self.page.read())
            self.definitions = self.soup.findAll("div", {"class": "definition"})
            if len(self.definitions) == 0:
                return "No definitions found on this page."
            elif len(self.definitions) < number:
                return "There are only " + str(len(self.definitions)) + " definitions on this page."
            else:
                return (HTMLParser.HTMLParser().unescape(self.definitions[number -1].text)).encode('utf-8')
        except Exception:
            return "Error retrieving definition for the term " + term + "."
                                                    
            
        
    def on_kick(self, c, e):
        kickedNick = e.arguments()[0]
        if kickedNick == self.nick: #only does the following if the bot was the one that is kicked
            time.sleep(10)#waits 10 seconds
            for channel in self.mychannels:
                self.connection.join(channel) #joins all the channels if kicked, joining a channel the bot is already in is okay
                
    def getMin(self):
        theTime = time.gmtime()
        return theTime.tm_min

    def getSec(self):
        theTime = time.gmtime()
        return theTime.tm_sec
    
    def get_version(self):
        return "BIGBEN BOT" #CTCP VERSION reply

    def fileUpdate(self):
        self.customResponsesFile = open("CUSTOMRESPONSES", "r")
        self.customResponses = self.customResponsesFile.readlines()
        self.customResponsesFile.close()
        self.messagesFile = open("RESPONSES", 'r')
        self.responses = self.messagesFile.readlines()
        self.messagesFile.close()
        self.nicksFile = open("NICKS", 'r')
        self.commandnicks = self.nicksFile.readlines()
        self.nicksFile.close()
        self.ignoreFile = open("IGNORE", 'r')
        self.ignores = self.ignoreFile.readlines()
        self.ignoreFile.close()
        
                
    def setupLog(self):
        outfile = open(logfile, "w")
        outfile.close() #creates logfile
        while 1: #run in a loop to keep updating list every 10 seconds
            time.sleep (1) #waits one second for the bot to join all channels, here for initial run
            for channel in self.channels:
                self.connection.send_raw("LIST " + channel)
                time.sleep(10) #waits so we don't overload the server
            self.logUsers(self.amounts)
            

    def wait(self): #sounds off the hour
        message = ''
        waitlength = 1
        changed = 0
        bongs = self.getHour()
        while 1:
            if (self.currentHour != self.getHour()) or (changed == 1):
                changed = 1
                bongs = bongs + 1
                if bongs > 12:
                    bongs = bongs - 12
                for i in range (0, bongs):
                    message += 'BONG '
                for channel in self.channels:
                    self.connection.privmsg(channel, message)
                message = '' #resets the message
                waitlength = 3600 - self.getSec()
            time.sleep(waitlength) #only checks once a second to greatly reduce CPU usage

    def logUsers(self, writeMe):
        write = 0
        outfile = open(logfile, 'r')
        for entry in writeMe:
            if entry != (outfile.readline().rstrip('\n')):
                write = 1
                outfile.close()
                break # only writes if the file has changed
        if write == 1:
            outfile = open(logfile, 'w')
            for entry in writeMe:
                outfile.write(entry)
                outfile.write('\n')
        outfile.close()
        self.amounts = []

    def on_list(self, connection, event):
        data = (str(event.arguments()[0]) + ' ' + str(event.arguments()[1]))
        self.amounts.append (data)
        
        
               
    def on_welcome(self, connection, event):
        for channel in self.mychannels:
            connection.join(channel)
        self.connection.privmsg("nickserv", "identify "+self.password) #identify with nickserv
        self.fileUpdate()
        
    def formulateMessage(self):
        hour = self.getHour()
        if hour == 0:
            hour = 12
        if self.getMin() == 0:
            return "OI IT'S " + str(hour) + " BONG"
        elif self.getMin() == 1:
            return "OI IT'S 1 BIT PAST " + str(self.getHour()) + " BONG"
        return "OI IT'S " + str(self.getMin()) + " BITS PAST " + str(hour) + " BONG"

    def magicConch(self):
        lines = len(self.responses)
        lineNum = random.randint(0, lines - 1)
        return self.responses[lineNum - 1].rstrip('\n')
        
    def sayWebpageTitle(self,url,event):
        headers = {'User-Agent' : 'Mozilla/5.0'} #our user agent prevents some 403 errors
        req = urllib2.Request(url, '', headers)
        try:
            title = HTMLParserObject.unescape(BeautifulSoup.BeautifulSoup(urllib2.urlopen(req).read()).title.string)
        except Exception:
            title = HTMLParserObject.unescape(BeautifulSoup.BeautifulSoup(urllib.urlopen(url)).title.string)
        title = title.strip() #removes leading and trailing whitespace
        title = re.sub('[\n]', '', title) #removes any newlines that are in the title
        #retrieves page titles and parses special characters
        title = title.encode('utf-8')
        if not title == "":
            self.connection.privmsg(event.target(), "Title: " + title)
    
    def on_pubmsg (self, connection, event):
        message = event.arguments()[0]
        source = event.source().split('!')[0]
        if source + "\n" not in self.ignores:
            if message == pubTimeCommand:
                self.connection.privmsg(event.target(), self.formulateMessage()) #Say what time it is
            elif message == PMTimeCommand:
                self.connection.notice(event.source().split('!')[0], self.formulateMessage()) #tell the user who says the PMTimeCommand what time it is
            elif message.startswith(".") and message.endswith("ing"):
                if " " not in message and ".bing" not in message: # doesn't let the bot bong or respond to commands with a space in them
                    response = message[:-3] #response starts as everything but the 'ing'
                    response = response + "ong"
                    response = response.lstrip('.')
                    self.connection.privmsg(event.target(), response)
            elif message.startswith(self.nick) and message.endswith("??"):
                for e in self.customResponses:
                    if message.lstrip(self.nick).lstrip(",: ").rstrip(" ??") == e.split("::")[0]:
                        self.connection.privmsg(event.target(), e.split("::")[1])
                        self.custom = 1 # tells the bot we have a custom reply
                if self.custom == 0: # if we have not had a custom reply
                    self.connection.privmsg(event.target(), self.magicConch())
                self.custom = 0 # resets the custom reply
            elif message.startswith(".tweet"): 
                if len(message.split(' ')) == 1:
                    username = event.source().split('!')[0]
                    #uses nick as Twitter username
                else:
                    username = message.split(' ')[1]
                try:
                    thread.start_new_thread(self.connection.privmsg, (event.target(), self.getTweets(username, int(message.split(' ')[2]))))
                    #tries to get the nth tweet
                except Exception:
                    thread.start_new_thread(self.connection.privmsg, (event.target(), self.getTweets(username, 1)))
                    #if n is not specified, we get the first tweet
            elif message.startswith(".urban"):
                if len(message.split(' ')) == 2:
                    term = message.split(' ')[1]
                    defnum = 1
                    thread.start_new_thread(self.connection.privmsg, (event.target(), self.urban(term, defnum)))
                    #accounts for the special case of the term being a number
                else:
                    try:
                        try:
                            defnum = int(message.split(' ')[-1])
                        except:
                            defnum = 1
                        term = message.replace(".urban ", "").replace(" " + str(defnum), "")
                        thread.start_new_thread(self.connection.privmsg, (event.target(), self.urban(term, defnum)))
                    except Exception:
                        thread.start_new_thread(self.connection.privmsg, (event.target(), "Usage: .urban word (definition number)"))
               
                    
            elif "http://" in message or "https://" in message:
                if not event.target() in self.silentChannels:
                    messageList = message.split(' ')
                    for element in messageList:
                        if element.startswith(("http://","https://"), ):
                            thread.start_new_thread(self.sayWebpageTitle, (element,event))
                        
    def on_privmsg (self, connection, event):  #the user specifies the channel after the command
        eventList = event.arguments()[0].split(' ')
        source = event.source().split('!')[0]
        if source + "\n" in self.commandnicks and eventList[0] == ".update":
            self.fileUpdate()
        if eventList[0] == privTimeCommand:
            self.connection.privmsg(eventList[1], self.formulateMessage()) #Say what time it is
        if eventList[0] == sayCommand:
            for i in range (2, len(eventList)): #starts at index 2 so we don't say the channel too
                self.array.append(eventList[i])
                self.array.append(' ') #creates a space between the words
            self.message = ''.join(self.array)
            self.connection.privmsg(eventList[1], self.message)
            self.message = ''
            self.array = [] #say what we say to the bot back to the channel

            
            
def main():
    global pubTimeCommand
    global privTimeCommand
    global sayCommand
    global PMTimeCommand
    global log
    global logfile
    global amounts# need to declare these as global so they can be modified
    arguments = []
    file = open (sys.path[0] + "/COMMANDS", "r")
    for line in file.readlines():
        arguments.append(line.strip('\n'))#remove the newlines from the list
    channels = arguments[6].split(' ')
    nick = arguments[8]
    network = arguments[2]
    port = int(arguments[4])
    password = arguments[10]
    name = arguments[12]
    pubTimeCommand = arguments[14]
    privTimeCommand = arguments[16]
    sayCommand = arguments[18]
    PMTimeCommand = arguments[20]
    log = arguments[22]
    logfile = arguments[24]
    silentChannels = arguments[26].split(' ')
    bot = Bot(channels, nick, network, port, password, name, silentChannels)
    bot.start()

if __name__ == "__main__":
    main()
